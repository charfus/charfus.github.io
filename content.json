{"meta":{"title":"Cha","subtitle":"about dev","description":"개발을 공부하며 부딪혔던 문제들을 기록합니다","author":"Haneul Cha","url":"https://haneulcha.github.io","root":"/"},"pages":[{"title":"about","date":"2020-09-12T15:37:24.000Z","updated":"2021-01-06T09:28:33.740Z","comments":true,"path":"about/index.html","permalink":"https://haneulcha.github.io/about/index.html","excerpt":"","text":"안녕하세요, 저는 차하늘입니다. 인생의 지침은 일희일비하지 않는 것… 개발하다가 마주친 문제들을 기록하고 있습니다. ( 비정기적으로… )"}],"posts":[{"title":"Git :: 궁금했던 것들","slug":"Git-궁금했던-것들","date":"2021-01-26T13:34:10.000Z","updated":"2021-01-26T15:04:07.250Z","comments":true,"path":"2021/01/26/Git-궁금했던-것들/","link":"","permalink":"https://haneulcha.github.io/2021/01/26/Git-%EA%B6%81%EA%B8%88%ED%96%88%EB%8D%98-%EA%B2%83%EB%93%A4/","excerpt":"","text":"항상 git을 제대로 쓰고 있지 않다는 생각을 갖고 있어서 오늘 git 문서와 learngitbranching을 훑었다. 기본적인 명령어들과 평소에 궁금했던 것들을 위주로 정리해서 남겨보려고 한다. branch커밋 사이를 가볍게 이동할 수 있는 어떤 포인터 같은 것 12$ git branch testing$ git checkout testing 브랜치가 어떤 커밋을 가리키는지 확인 1234$ git log --oneline --decoratef30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface34ac2 Fixed bug #1328 - stack overflow under certain conditions98ca9 The initial commit of my project 다시 HEAD가 master 브랜치가 가리키는 커밋을 가리키도록 checkout 1$ git checkout master 워킹 디렉토리의 파일도 그 시점으로 되돌려 놓음 이거 모르고 자료 다 날아간 줄 알았던 적이 있음1234567$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project 두 갈래로 갈라진 브랜치들 git clone원격 브랜치&lt;remote name&gt;/&lt;branch name&gt; 로컬 저장소에 원격 브랜치인 origin/main이 생성 ! = 원격 저장소의 상태를 반영. 이를 checkout을 하면 분리된 HEAD 모드로 간다. (여기에서 새로 커밋해도 origin/main이 갱신되지 않음) 내가 다른 곳에서 작업을 하고 원격 저장소와 내 작업을 공유한 다음에야 원격 브랜치는 갱신된다. 주 원격 저장소는 보통 origin이다. git clone 하면 자동으로 origin으로 설정됨. 리모트 트래킹 브랜치리모트 브랜치를 추적하는 레퍼런스이자 브랜치 git fetch원격 저장소의 커밋을 로컬 저장소로 다운로드. 가져오기만 ! ( → 원격 브랜치 origin/main도 이를 반영하여 업데이트 ) “동기화” 12$ git fetch 원격저장소 &lt;source&gt;:&lt;destination&gt;$ git fetch origin foo = 원격 저장소의 foo 브랜치에서 현재 로컬에 없는 커밋들을 가져와 로컬의 ‘origin/foo’ 브랜치 아래에 추가. source : 받아올 커밋이 있는 원격에 있는 place destination : 그 커밋들을 받아올 local의 place 로컬의 foo에 그냥 커밋을 추가하지 않고 로컬의 원격 브랜치 o/foo에 커밋들을 추가한 이유는 foo 브랜치에 작업을 했을 가능성 때문. git fetch는 **로컬의 원격 브랜치(origin/foo)**가 아닌 브랜치는 갱신하지 않는다. 체크아웃된 브랜치에 fetch 할 수 없고 체크아웃 되지 않은 브랜치만 가능하다. git pull내 작업을 업데이트해서 변경들을 반영하기. 대부분 git fetch 명령을 실행하고 나서 자동으로 git merge 명령을 수행하는 것 뿐이다. clone 이나 checkout 명령을 실행하여 추적 브랜치가 설정되면 git pull 명령은 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 추적 브랜치를 merge 한다. “일반적으로 fetch 와 merge 명령을 명시적으로 사용하는 것이 pull 명령으로 한번에 두 작업을 하는 것보다 낫다.” 고 git 문서에는 나와있다. 12$ git fetch; git merge origin/main= $ git pull git push내 작업을 다른 사람들과 공유, “공개”하는 과정 정해진 원격 저장소에 내 코드의 변경 사항을 업로드 ⇒ 원격 저장소가 새 커밋들을 합치고 갱신 ⇒ 원격 저장소의 반영인 내 원격 브랜치 origin/main까지 갱신 12$ git push &lt;remote&gt; &lt;place&gt;$ git push origin main = 내 저장소에 있는 “main”라는 이름의 브랜치로 가서 모든 커밋들을 수집 → “origin”의 “main” 브랜치로 가서 이 브랜치에 부족한 커밋들을 채워 넣고 완료되면 알려주기 place : 두 저장소 간에 동기화 작업을 할 “장소”를 지정. git에게 어디로 부터 커밋이 오는지, 그리고 어디로 커밋이 가야하는지 알려준다 ⇒ 현재 우리가 체크아웃한 브랜치는 무시하고 명령을 수행 체크아웃된 브랜치에 상관없이 원격 저장소를 추적하는 브랜치(main)에서 push HEAD가 원격 저장소를 추적하는 브랜치에 체크아웃 되지 않았는데 그냥 git push만하면 명령 실패 12$ git push origin &lt;source&gt;:&lt;destination&gt;$ git push origin main:&lt;새로운 브랜치&gt; 예를 들면, 12$ git push origin foo:main - foo 자리로 main 원격 브랜치를 업데이트$ git push origin C5:foo - C5 자리로 foo 원격 브랜치를 업데이트 로컬 저장소의 브랜치는 자동으로 리모트 저장소로 전송되지 않고, 명시적으로 브랜치를 Push 해야 정보가 전송된다. 따라서 리모트 저장소에 전송하지 않고 로컬 브랜치에만 두는 비공개 브랜치를 만들 수 있다. 또한 다른 사람과 협업하기 위해 토픽 브랜치만 전송할 수도 있다. git 문서 예시 12345678910111213141516$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit * [new branch] serverfix -&gt; serverfix// serverfix 라는 로컬 브랜치를 서버로 Push 하는데 리모트의 serverfix 브랜치로 업데이트=$ git push origin serverfix:serverfix// “로컬의 serverfix 브랜치를 리모트 저장소의 serverfix 브랜치로 Push 하라”$ git push origin serverfix:awesomebranch// 리모트 저장소에 serverfix 라는 이름 대신 다른 이름을 사용 나중에 누군가 저장소를 fetch 하고 나서 서버에 있는 serverfix 브랜치에 접근할 때 origin/serverfix 라는 이름으로 접근할 수 있다. 1234567$ git fetch originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From https://github.com/schacon/simplegit* [new branch] serverfix -&gt; origin/serverfix serverfix 라는 브랜치가 생기는 것이 아니라 그저 수정 못 하는 origin/serverfix 브랜치 포인터가 생기는 것. git merge origin/serverfix을 해주어야 merge 리모트 트래킹 브랜치에서 시작하는 새 브랜치를 만들려면 123$ git checkout -b serverfix origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch &#x27;serverfix&#x27; ⇒ origin/serverfix 에서 시작하고 수정할 수 있는 serverfix 라는 로컬 브랜치 생성 히스토리가 엇갈릴 때예를 들어 나는 C1을 기반으로 하는데 원격 저장소는 이미 C2까지 갱신된 상태면 git push가 아무 효과도 없다. 이럴 때에는 내 작업을 원격 저장소의 최신 상태로 업데이트 하기 먼저 이미 업데이트된 원격 저장소를 가져온 다음에 내 작업을 올리기 rebase123$ git fetch // 원격 저장소의 변경정보 가져오기$ git rebase origin/main // 새 변경들로 내 작업을 리베이스$ git push 내가 C3에 있을 때 fetch해서 C2를 가져오고 → rebase해서 그 밑으로 들어가기 → 원격 저장소에 업데이트 merge내 작업을 옮기지는 않지만 (merge 커밋 생성) git에게 원격 저장소의 변경을 합쳤다고 알려주는 방법. 이제 원격 브랜치가 내 브랜치의 부모 -&gt; 내 커밋이 원격 브랜치의 모든 커밋을 반영 123$ git fetch // 원격 저장소의 변경 정보 가져오기$ git merge origin/main // 새 작업을 내 작업으로 병합 (원격 저장소의 변경을 반영)$ git push 12$ git pull --rebase$ git push feature 브랜치 (토픽 브랜치) 병합보통 개발자들은 feature 브랜치(=토픽브랜치 / main브랜치가 아닌 작업을 위해 임시로 만든 브랜치)에 작업을 하고, 준비가 되면 그 작업을 통합한다. 어떤 개발자들은 main 브랜치에 있을때만 push와 pull을 수행한다. 이렇게하면 main는 항상 원격 브랜치 (o/main)의 상태와 항상 최신의 상태로 유지할 수 있다. feature 브랜치의 작업을 main 브랜치로 통합하기 원격저장소에서 push하고 pull하기","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"git","slug":"git","permalink":"https://haneulcha.github.io/tags/git/"},{"name":"til","slug":"til","permalink":"https://haneulcha.github.io/tags/til/"}]},{"title":"토이 프로젝트:: 웹 보드 #2 saga","slug":"토이프로젝트-웹-보드-2","date":"2021-01-23T12:59:20.000Z","updated":"2021-01-23T13:53:58.352Z","comments":true,"path":"2021/01/23/토이프로젝트-웹-보드-2/","link":"","permalink":"https://haneulcha.github.io/2021/01/23/%ED%86%A0%EC%9D%B4%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9B%B9-%EB%B3%B4%EB%93%9C-2/","excerpt":"","text":"데이터 형식을 정한 다음에는 로컬스토리지에 저장하는 함수들을 utils 폴더에 만들었고 (폴더 이름을 더 명확하게 짓고 싶었는데 다들 어떻게 정하는지 궁금하다) store 폴더에 리덕스 관련 함수들을 작성했다. 그러고 나서 saga 폴더에 action을 캐치하는 함수들을 만들었다. 사실 나도 saga가 처음이라 가장 기본적인 사용 예시 코드들을 여기저기서 긁어 모아 공부하면서 코드를 작성한 탓에 내 지식이 정확한지 의심스럽다. 그래서 saga 자체에 대한 설명보다는 내가 실제로 어떻게 이해하고 적용했는지를 기록해보려고 한다. saga우선 saga를 쓰면서 좋았던 건 내가 action을 dispatch 하면 saga가 이를 캐치하기 때문에 여기에 비동기 통신과 같은 side-effect를 손 쉽게 연결할 수 있다는 거였다. 내 경우에는 로컬 스토리지를 썼지만 그냥 서버랑 통신한다고 가정하고 saga를 활용했다. 컴포넌트에서 REQ_로 시작하는 action, 예를 들어 REQ_CREATE_BOARD를 dispatch하면 이를 saga가 캐치해서 로컬스토리지에 새로운 보드를 생성한 다음, 생성된 보드 정보를 받아 나름 가공한 뒤, 다시 CREATE_BOARD를 dispatch 할 때 이 데이터를 payload에 포함시켰다. 1dispatch(reqCreateBoard()); 12345export function reqCreateBoard(): BoardActionTypes &#123; return &#123; type: REQ_CREATE_BOARD, &#125;;&#125; /saga/board.tsx 123456789101112131415161718192021function* createBoard() &#123; // 로컬 스토리지에 저장 const boardLS: IBoardLS = yield call(createBoardLS); const boardRD: actions.IBoard = &#123; index: boardLS.index, name: boardLS.name, timestamp: boardLS.timestamp, &#125;; // 가공된 데이터를 담아 dispatch yield put(&#123; type: actions.CREATE_BOARD, payload: boardRD, &#125;); const isOn: IIsOnLS = yield call(getIsOnLS); // 새로 생성된 보드로 화면전환 하기 위해 isOn도 dispatch yield put(&#123; type: actions.GET_ISON, payload: isOn, &#125;);&#125; 123456789function* watchBoard() &#123; //REQ_CREATE_BOARD 액션을 캐치해서 createBoard 함수를 호출 yield takeEvery(actions.REQ_CREATE_BOARD, createBoard); //...&#125;export default function* boardSaga(): Generator&lt;StrictEffect, void, unknown&gt; &#123; yield all([fork(watchBoard), fork(watchBoardList)]);&#125; function에 붙는 *는 ES6의 Generator 문법이고 yield문을 포함한다는데 사실 아직 제대로 이해는 못했고 거의 async/await처럼 쓴 것 같다. call은 자바스크립트의 그 call 메소드처럼 쓴다고 들었다. 두번째 인자에 action으로 전달된 payload를 넣어서 컴포넌트에서 데이터를 받아왔다.1yield call(updateIsOnLS, action.payload.board, action.payload.boardId); put은 dispatch의 역할을 한다고 한다. select로 saga 내부에서 state에 접근할 수도 있었다. 처음에 당연히 saga에서 state를 가져올 수 없을 줄 알았는데 역시 나같은 고민을 하는 사람이 있었는지 스택오버플로우에서 답을 찾았다. 리덕스의 useSelector와 같은 역할을 하는 api라고 한다.1234567891011export const getIsOn = (state: actions.IrootState): actions.IIsOnState =&gt; state.isOn;function* getPosts() &#123; const isOn = yield select(getIsOn); const postsLS: Array&lt;IPostLS&gt; = yield call(getPostsLS, isOn.boardId); yield put(&#123; type: actions.GET_POSTS, payload: postsLS, &#125;);&#125; takeEvery는 REQ_CREATE_BOARD 액션을 캐치해서 createBoard 함수를 호출한다. 대부분의 로직을 위와 같은 과정을 기반으로 작성했다. 사실 그렇게 깔끔한 것 같진 않지만 saga가 처음이라 기본부터 배운다는 생각으로 크게 욕심을 내진 않았다. 참고한 글로는 saga가 처음이라 우선 원래 쓰던 thunk랑 어떻게 다른지 찾아봤다. 그 중에 thunk와 비교하는 블로그 글이 도움이 되었다. 스택오버플로우 : saga에서 selector로 state에 접근하기 saga 문서 한글 번역 나중에 읽으려고 즐겨찾기에 넣어놓은 타입스크립트 + 리덕스 사가 - 나중에 꼭 적용해보고 싶다 마찬가지로 타입스크립트 + 리덕스 사가 - 좀 더 최근 글이다.","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"web-board","slug":"web-board","permalink":"https://haneulcha.github.io/tags/web-board/"},{"name":"saga","slug":"saga","permalink":"https://haneulcha.github.io/tags/saga/"}]},{"title":"토이 프로젝트:: 웹 보드 #1","slug":"토이-프로젝트-웹-보드","date":"2021-01-23T07:53:19.000Z","updated":"2021-01-23T09:11:28.831Z","comments":true,"path":"2021/01/23/토이-프로젝트-웹-보드/","link":"","permalink":"https://haneulcha.github.io/2021/01/23/%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%9B%B9-%EB%B3%B4%EB%93%9C/","excerpt":"","text":"지난 일주일 동안 웹 보드를 하나 만들었는데 까먹기 전에 이런 저런 기록을 남겨보기로 한다. 작동 방식우선 프로젝트 자체는 웹 브라우저에서 작동하는 메모장이라고 생각하면 될 듯 하다. 구글의 Keep이나 마소의 OneNote 같은 것을 생각하면서 만들었다. 보드를 추가하거나 삭제할 수 있고, 각 보드에 포스트 잇 형태의 메모를 남길 수 있다. 메모는 브라우저의 로컬 스토리지에 저장되어 창을 닫았다가 다시 열어도 그대로 남아있다. 물론 로컬 스토리지를 지우면 전부 사라진다. 스택React, Typescript, Redux, Redux-Saga를 사용했다. 이중에서 실제로 코드를 작성해본 것은 React와 Redux 뿐이다. Typescript는 계속 공부를 하다가 처음 적용해봤고, saga는 이름만 들어봤지 전혀 생소했는데 앞으로는 원래 쓰던 thunk 대신할 것 같다. 둘다 쓰길 잘했다는 생각이 들었다! 다만 더 좋은 코드를 작성하고 싶었는데 처음이기도 하고 역량이 못 미쳐서 아쉬웠다. 제작 구상우선, 제일 먼저 한 것은 데이터를 로컬스토리지에 저장하고 리덕스로 상태 관리를 하는 로직을 짜는 것이였다. 사실 대단한 건 없지만 생각보다 까다롭고 시간도 오래 걸렸다. 우선 어떤 형태로 데이터를 로컬스토리지에 저장할지 구상하고, 로컬스토리지에서 불러온 데이터를 어떻게 리덕스로 상태 관리할지를 결정했다. 이 과정에서 나름 철저했다고 생각했는데 나중에 추가한 데이터 속성도 있고, 리덕스의 본래 목적을 완전히 착각해서 초반에 애를 먹었다. (리덕스는 말그대로 전역에서 접근할 데이터를 좀 더 자유롭게 관리하는 도구여야 하는데, 리덕스랑 로컬스토리지의 역할을 거의 같은 것으로 착각을 했다.) 로컬스토리지에 저장되는 데이터 형식로컬스토리지의 key는 두 개를 사용했다. boards와 isOn - 전자는 보드 객체들이 담긴 배열을, 후자는 최근에 본 보드 정보를 담은 하나의 객체를 저장한다. [ board ] boards 배열에 저장되는 보드 객체 123456&#123; index: number, name: string, posts: Array, timestamp: number&#125; index는 혹시 보드들을 재배열할 필요가 있을까 싶어서 넣었는데 활용하진 않았다. name은 보드 제목, posts는 포함하는 포스트 객체들 배열, timestamp는 생성 시간이다. timestamp는 고유 id로도 활용했다. timestamp도 나쁘지 않을 것 같아서 따로 uuid를 쓰지는 않았다. [ post ] board 객체의 posts 속성에 배열로 저장되는 post 객체 12345678910&#123; boardId: number, title: string, content: string, *isOpen: boolean, position: &#123;x: number, y: number&#125; size: &#123;width: number, height: number,&#125; *modified: number, timestamp: number &#125; boardId는 속한 보드의 timestamp이고, title과 content는 메모의 내용, isOpen은 메모의 펼침 여부, position은 보드 위에서의 좌표, size는 메모의 크기, modified는 수정된 시각, timestamp는 생성된 시각이다. 이 중 *가 붙은 속성은 중간에 작업 중에 추가했다. isOpen은 내가 생각을 못한 부분이고, modified는 포스트 폼의 autofocus를 위해 추가했다. modified에 대해 좀 더 설명하면, 포스트가 최초 생성될 때는 input field에 autufocus가 되어야 하지만 기존 데이터를 불러올 때는 그럴 필요가 없다. 따라서 modified가 초기 생성 시에는 0으로 저장되고, 포커스가 사라지거나 엔터를 누르면 메모 내용과 함께 modified가 업데이트되어 다음에 포스트들을 불러올 때는 input field가 아니라 내용 자체가 보이게 된다. 위의 두 자료는 배열로 저장했다. [ isOn ] 1234&#123; board: string, boardId: number&#125; 창을 닫았다가 열어도 마지막에 본 보드에서 시작하기 위해 따로 이렇게 저장했다. 처음에는 timestamp만 저장했다가 보드 위에 보드 이름을 띄우기 위해서 board 이름을 추가했다. 리덕스 상태 관리를 위한 데이터 형식각각 board, post, isOn 이렇게 세 reducer로 나누어서 관리했다. 각각 전체 보드 리스트를 담은 배열, 현재 보드에 보이는 포스트들을 담은 배열, 현재 보고 있는 보드에 관한 객체 데이터를 담고 있다. 12345export const rootReducer = combineReducers(&#123; board: boardReducer, post: postReducer, isOn: isOnReducer&#125;) [ boards ] 12345&#123; index: number; name: string; timestamp: number;&#125; 사실 무슨 생각이였는지 모르겠는데 굳이 로컬스토리지에서 가져오는 보드 리스트에서 저렇게 posts 속성을 빼고 저장했다. 모든 데이터를 저장하면 메모리에 문제가 있지 않을까? 해서 저렇게 한 건데 실제로 그런지는 모른다… [ isOn ] 1234&#123; board: string; boardId: number;&#125; 이건 위의 [ 최근에 본 보드 ]를 그대로 가져왔다. [ posts ] 12345678910&#123; title: string; content: string; position: &#123; x: number; y: number &#125;; size: &#123; width: number; height: number &#125;; isOpen: boolean; boardId: number; timestamp: number; modified: number;&#125; 역시 위의 포스트 형식과 동일하다. 각 보드 객체의 posts 속성에서 가져온 데이터들이다. 보드가 새로 생성 및 삭제되거나 유저가 보고 있는 보드가 바뀔 때마다 isOn이 업데이트 되고, isOn이 업데이트될 때마다 posts의 데이터도 업데이트 된다. (이 부분은 saga로 구현했다.) 중간에 계속 수정되긴 했지만 아무튼 가장 처음에는 이렇게 데이터 형식을 마련했다.","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"web-board","slug":"web-board","permalink":"https://haneulcha.github.io/tags/web-board/"}]},{"title":"초면의 svelte","slug":"초면의-svelte","date":"2021-01-09T08:21:42.000Z","updated":"2021-01-23T07:48:34.754Z","comments":true,"path":"2021/01/09/초면의-svelte/","link":"","permalink":"https://haneulcha.github.io/2021/01/09/%EC%B4%88%EB%A9%B4%EC%9D%98-svelte/","excerpt":"","text":"친구가 해보라고 해서 스벨트로 투두리스트 만들어보기로 했다.만들기 전에 대체 스벨트가 뭔지 좀 알고 시작하는 게 좋을 것 같아서 홈페이지에서 대충 정보를 긁어 모아봤다. svelte.dev 헤드라인은 더 적은 코드 - 보일러플레이트가 없는 컴포넌트 버츄얼 돔 X - 코드를 바닐라 JS로 컴파일 ➡ 어플리케이션이 빠르게 시작 및 구동 진짜(!) 리액티브 - 복잡한 상태 관리 라이브러리 불필요, 자바스크립트 자체가 리액티브 할 수 있도록 이어지는 설명은 리액트나 뷰처럼 작업의 대부분이 브라우저에서 이루어지는 것이 아니라, 스벨트는 그 작업을 어플리케이션을 빌드하는 컴파일 단계로 옮겨온다. 버츄얼 돔을 쓰는 대신 상태가 변할 때 DOM을 “surgically” 업데이트 하는 코드를 작성한다. 그리고 재작년 봄 Rich Harris가 쓴 블로그 글을 보니 스벨트는 우선 컴포넌트 프레임워크. “전통적인 프레임워크에서는 프로그래머가 선언적 관리 중심 코드를 작성해야 하고, 그래서 브라우저는 버츄얼 돔 같은 기술을 써서 이 선언적 구조를 DOM 작업으로 바꾸느라 과부하가 걸린다. 버츄얼 돔은 frame budget(정확하게 무슨 뜻인지 모르겠다. 프레임을 구성하는 데 드는 시간과 비용?)을 잡아먹고 garbage collector가 필요하다. 반면 스벨트는 빌드할 때 작동하고 컴포넌트를 매우 효율적인 명령형 코드로 바꾸어 DOM을 “surgically” 업데이트 한다.” 그리고 “부자연스러운 코드”, “가비지 콜렉터로 인한 불필요한 작업들” 때문에 Hook을 거부하는 듯. 임베디드 디바이스나 애니메이션 위주 인터렉티브에 쓰이는 프레임 워크에는 맞지 않다고 한다. 🚩 결론 : “the best API is no API at all” “그냥 언어를 사용하겠다.” 앞으로 Next.js와 비슷한 Sapper, Svelte Native + 여러 에디터 익스텐션, 신택스 하이라이터, 컴포넌트 키트, 데브툴스 + 타입스크립트 지원을 계획하고 있다고 한다. 튜토리얼 We can use curly braces inside attributes. &quot;&#123;name&#125; dances.&quot; CSS 선언: these rules are scoped to the component. 다른 컴포넌트를 nested 해도 지금 컴포넌트의 CSS가 적용되지 않음 string 내부의 HTML 태그 적용하고 싶을 때 &lt;p&gt;&#123;@html string&#125;&lt;/p&gt;","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"svelte","slug":"svelte","permalink":"https://haneulcha.github.io/tags/svelte/"},{"name":"doc","slug":"doc","permalink":"https://haneulcha.github.io/tags/doc/"}]},{"title":"TIL: package.json의 homepage와 CORS","slug":"TIL-package-json의-homepage와-CORS","date":"2021-01-08T11:00:33.000Z","updated":"2021-01-09T08:21:03.024Z","comments":true,"path":"2021/01/08/TIL-package-json의-homepage와-CORS/","link":"","permalink":"https://haneulcha.github.io/2021/01/08/TIL-package-json%EC%9D%98-homepage%EC%99%80-CORS/","excerpt":"","text":"요즘은 조심스럽게 주변 사람들에게 갈피를 홍보하고 있다. 그러던 중 내 브라우저에서는 뜨지 않던 CORS 이슈가 또 발생한다는 안타깝고 열받는 소식을 듣고 이 문제를 해결하기로 했다. 문제 상황 이 오류 메세지를 보면 알 수 있겠지만 현재 origin는 http로 시작하고, 이 origin에서 요청하는 api 주소는 https로 시작한다. CORS는 HTTP인지 HTTPS인지도 따지기 때문에 접근이 차단된 것이다. 그렇지만 하나는 http이고 다른 하나는 https인 이유가 무엇인지 !?!?문제 원인우선, 프론트를 CRA로 만들었는데 무슨 생각이였는지 package.json의 homepage를 http://galpi.herokuapp.com 으로 설정해놓았다. 이 속성이 그냥 단순한 메모용이라고 생각했는데 build 할 때 상대 주소를 결정하는 중요한 역할을 하고 있었다. 자세한 설명은 CRA 문서에 나와있다. 이 부분 때문에 현재의 origin이 잘못 설정된 것이 아닌가 추측한다. 문서로 이동 그렇다면 왜 https가 아닌 http로 적었는가 ? 단순하다. heroku는 무료 배포 서비스를 이용하는 유저에게 https라는 사치를 허가하지 않는다고 제멋대로 생각했기 때문이다… 근데 확실한지는 모르겠다. 브라우저에서 url을 확인하면 https로 뜨기에 그런 것 같을 뿐. 확실한 근거는 못 찾았다. 친구 말로는 aws에서 배포하면 따로 https를 (매우 복잡한 과정을 거쳐) 설정해주어야 한다고 한다. 해결homepage 삭제하고 다시 빌드 그 외 알게 된 사실처음부터 원인을 알았던 게 아니기 때문에 이래저래 CORS 공부를 해야했다. 개발 공부를 시작한 이유로 열 번 넘게 CORS를 검색했던 것 같은데 이제서야 CORS MDN 문서를 좀 이해한 것 같다. 나에게 특히 도움이 됐던 정보는 1) 교차 출처 리소스 공유는 추가 HTTP 헤더를 사용해서 서로 다른 출처에서 자원에 접근한다는 점과 2) 브라우저에서 플래그로 withCredential = true로 요청했을 때, 서버는 Access-Control-Allow-Credentials: true 뿐만 아니라 Access-Control-Allow-Origin 헤더 값을 와일드카드(*)가 아닌 하나의 origin을 보내주어야 한다는 점이다. 그 외에 pre-flight에 관한 설명도 자세히 나와있는데 대략 그런 것이 있구나하고 우선 넘어갔다. 사실 프론트에서 axios의 디폴트를 withCredential = true로 설정해놨는데 그 때 이 설정값의 의미를 제대로 이해하지 못했던 것 같다. CORS 문서 읽으면서 이제야 그 설정이 어떻게 다른 요소들과 연결되어있는지 조금 알게 되었다. 그래서 마지막으로 백엔드에서 cors 설정을 추가해줬다. 12345678910import express from &quot;express&quot;;import cors from &quot;cors&quot;;const app = express();const corsOpt = &#123; origin: &quot;https://galpi.herokuapp.com&quot;, credentials: true&#125; app.use(cors(corsOpt)) 아마 쿠키 관련된 요청에만 적용하는 것으로 더 구체화 해야할 것 같다는 예감이 지금 불현듯 들지만 우선은 이렇게 해두었다.","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"galpi","slug":"galpi","permalink":"https://haneulcha.github.io/tags/galpi/"},{"name":"deploy","slug":"deploy","permalink":"https://haneulcha.github.io/tags/deploy/"},{"name":"TIL","slug":"til","permalink":"https://haneulcha.github.io/tags/til/"},{"name":"CORS","slug":"cors","permalink":"https://haneulcha.github.io/tags/cors/"},{"name":"CRA","slug":"cra","permalink":"https://haneulcha.github.io/tags/cra/"}]},{"title":"로그인 유지가 되지 않을 때","slug":"간신히-배포했더니-로그인-유지가-되지-않을-때","date":"2020-12-31T13:19:24.000Z","updated":"2021-01-06T09:25:23.696Z","comments":true,"path":"2020/12/31/간신히-배포했더니-로그인-유지가-되지-않을-때/","link":"","permalink":"https://haneulcha.github.io/2020/12/31/%EA%B0%84%EC%8B%A0%ED%9E%88-%EB%B0%B0%ED%8F%AC%ED%96%88%EB%8D%94%EB%8B%88-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%9C%A0%EC%A7%80%EA%B0%80-%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C/","excerpt":"","text":"배포하려고 계속 수정하는 과정에서 가장 막막했던 문제가 간신히 메인 페이지가 뜨는 데까지는 성공했는데 (그래서 이제 정말 끝난 줄 알았는데) 로그인을 해보니 다른 페이지로 넘어가는 순간 로그인이 풀려버리는 것이였다. 분명 개발할 때는 쿠키가 브라우저에 저장되면서 세션에서 유저 로그인 여부를 확인할 수 있었기 때문에 전혀 예상 못한 문제였다. 근데 정말 뭐가 문제인지 너무 막막했다. 쿠키 유효 기간 너무 짧은가 해서 세션 설정, 쿠키 설정 다 건드려보고 값도 바꿔봤는데 그대로 였다. redis에 문제가 생긴 건가 하고 redis 설정도 다시 해봤다. 지금 생각하니 잘못된 접근이였다. 로그인 유지가 안 되는데 왜 저장소들을 들여다보고 있어. 쿠키가 내 브라우저에 계속 남아있는지 아닌지부터 봐야지. 이래서 3시간 이상 연속으로 책상 앞에 앉아 있으면 안 되고 밤에는 잠을 자야한다. 아무튼 그 다음 날 일어나서 이것저것 after login cookie disappear, not saved 뭐 이런 단어로 검색을 했다가 간신히 방법을 찾았다. 결국 ‘expree-session’ 문서에 해결 방법이 있었다. 세션 설정 중 cookie.secure는 true일 경우, Secure를 설정한다. 즉, HTTPS 연결이 아닌 경우 클라이언트는 서버로 cookie를 보내지 못하고, cookie가 세팅되지 않는다. 다만, 프록시로 nodejs 서버를 사용하고 이 조건을 true로 세팅한 경우에 익스프레스에서 “trust proxy”를 설정해야 한다. 12345678var app &#x3D; express()app.set(&#39;trust proxy&#39;, 1) &#x2F;&#x2F; trust first proxyapp.use(session(&#123; secret: &#39;keyboard cat&#39;, resave: false, saveUninitialized: true, cookie: &#123; secure: true &#125;&#125;)) 그 외에 auto로도 설정할 수 있다고 한다.","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"galpi","slug":"galpi","permalink":"https://haneulcha.github.io/tags/galpi/"},{"name":"deploy","slug":"deploy","permalink":"https://haneulcha.github.io/tags/deploy/"}]},{"title":"CSP(Content Security Policy)","slug":"CSP-Content-Security-Policy","date":"2020-12-26T11:00:19.000Z","updated":"2020-12-26T11:38:55.552Z","comments":true,"path":"2020/12/26/CSP-Content-Security-Policy/","link":"","permalink":"https://haneulcha.github.io/2020/12/26/CSP-Content-Security-Policy/","excerpt":"","text":"결론서버에서 helmet 메소드로 설정할 수 있었다.","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"galpi","slug":"galpi","permalink":"https://haneulcha.github.io/tags/galpi/"},{"name":"deploy","slug":"deploy","permalink":"https://haneulcha.github.io/tags/deploy/"}]},{"title":"Global Object Id","slug":"Global-Object-Id","date":"2020-10-19T13:43:20.000Z","updated":"2020-12-26T10:38:00.000Z","comments":true,"path":"2020/10/19/Global-Object-Id/","link":"","permalink":"https://haneulcha.github.io/2020/10/19/Global-Object-Id/","excerpt":"","text":"20년 10월 19일 22시 43분 현재 내가 처한 상황:사람들이 올릴 각 포스트를 볼 수 있는 url이 필요하다. 무엇을 포스트의 고유한 식별자로 하지. mongoDB의 _id를 그대로 노출 시키기는 뭔가 찜찜하다. 유저 프로필의 경우엔 그냥 username으로 했는데… 인스타에 들어가서 포스트를 클릭해보니 보니 그리 길지 않은 고유 아이디를 url로 쓰고 있다. 어찌저찌 검색을 해보니 키워드는 ‘global object id’ 정도인 것 같고, ‘auto increment’에 대한 포스팅과 스택오버플로우의 질문들도 발견했다. ‘인덱스’와 ‘샤딩’은 아직 어디에 어떻게 쓰이는지 잘 모르겠다.그리고 ‘shortid’라는 npm 패키지도 발견했다. 해결하자… 12월 26일 배포까지 끝난 시점:이 고민은 사실 별 건 아니였다. nanoid, shortid, uuid 등 그냥 목적에 맞는 uuid 패키지를 검색해서 schema에서 uuid 생성 함수를 적용하니 해결되었다. mongoDB에서 원래 자동 생성되는 _id를 대신해서 uuid를 쓰는 것도 가능한데 나는 uuid 프로퍼티를 따로 추가했다. 처음에 왜 _id를 노출시키는 게 찜찜했는지는 나도 잘 모르겠다. 이후에 정렬을 해야할 일이 생길지도 모르겠다는 생각이 들어서 uuid와 별개로 index를 추가해서, 유저가 포스팅 할 때마다 increment 되도록 mongoDB 쿼리를 뒤져서 함수를 작성했다. 12345const index &#x3D; await Sequence.findOneAndUpdate( &#123; user &#125;, &#123; $inc: &#123; uid: 1 &#125; &#125;, &#123; new: true &#125; ); 개발 중간에 알아차린 실수는 uuid 생성 함수를 딸랑 쓰면 안 되고, 콜백으로 처리해야 한다는 점이였다. 처음에 딸랑 nanoid() 이렇게만 썼다가 모든 포스트의 uuid가 동일해졌고, 정반대의 목적으로 uuid를 활용한 꼴이 되었다. 12345678const postSchema &#x3D; new Schema(&#123; ... uuid: &#123; type: String, default: () &#x3D;&gt; nanoid(), &#125;, ...&#125; 결과적으로 모든 포스트가 /p/:uuid 주소로 각각 url을 갖게 되었다.","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"mongoDB","slug":"mongodb","permalink":"https://haneulcha.github.io/tags/mongodb/"},{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"galpi","slug":"galpi","permalink":"https://haneulcha.github.io/tags/galpi/"}]},{"title":"블로그를 만들었다","slug":"블로그를-만들었다","date":"2020-09-13T01:59:00.000Z","updated":"2020-09-15T02:23:56.711Z","comments":true,"path":"2020/09/13/블로그를-만들었다/","link":"","permalink":"https://haneulcha.github.io/2020/09/13/%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%97%88%EB%8B%A4/","excerpt":"","text":"인터넷을 접한지 20년이 다 되어가고, 그 동안 스쳐지나간 개인 홈페이지, 미니홈피, 블로그가 수십 개다…그 중 하나만 진득하게 했더라면… (사실 크게 달라진 것 없었겠지만…)다 큰 성인이 되고나서도 한참 후에야 이렇게 또 블로그를 하나 만들었다.이번에는 또 얼마나 가려나.. 라는 생각은 하지 않고 그냥 이것저것 기록을 해보겠다.대신 좀 더 책임감 있는 포스팅이 되길 바라고 스스로 다짐…👴","categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[]}],"categories":[{"name":"Post","slug":"post","permalink":"https://haneulcha.github.io/categories/post/"}],"tags":[{"name":"git","slug":"git","permalink":"https://haneulcha.github.io/tags/git/"},{"name":"til","slug":"til","permalink":"https://haneulcha.github.io/tags/til/"},{"name":"project","slug":"project","permalink":"https://haneulcha.github.io/tags/project/"},{"name":"web-board","slug":"web-board","permalink":"https://haneulcha.github.io/tags/web-board/"},{"name":"saga","slug":"saga","permalink":"https://haneulcha.github.io/tags/saga/"},{"name":"svelte","slug":"svelte","permalink":"https://haneulcha.github.io/tags/svelte/"},{"name":"doc","slug":"doc","permalink":"https://haneulcha.github.io/tags/doc/"},{"name":"galpi","slug":"galpi","permalink":"https://haneulcha.github.io/tags/galpi/"},{"name":"deploy","slug":"deploy","permalink":"https://haneulcha.github.io/tags/deploy/"},{"name":"TIL","slug":"til","permalink":"https://haneulcha.github.io/tags/til/"},{"name":"CORS","slug":"cors","permalink":"https://haneulcha.github.io/tags/cors/"},{"name":"CRA","slug":"cra","permalink":"https://haneulcha.github.io/tags/cra/"},{"name":"mongoDB","slug":"mongodb","permalink":"https://haneulcha.github.io/tags/mongodb/"}]}